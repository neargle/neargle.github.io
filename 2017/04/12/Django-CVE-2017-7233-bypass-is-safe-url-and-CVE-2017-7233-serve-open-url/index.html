<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  
  <title>Django的两则url跳转漏洞:CVE-2017-7233和CVE-2017-7234分析 - Nearg1e</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script type="text/javascript" src="/js/highlight.pack.js"></script>
  <script type="text/javascript" src="http://tajs.qq.com/stats?sId=58637942" charset="UTF-8"></script>
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link rel="alternative" href="/atom.xml" title="Nearg1e" type="application/atom+xml">
  
  <!--[if lt IE 9]>
    <script type="text/javascript" src="/js/html5.js"></script>
    <script type="text/javascript" src="/js/css3-mediaqueries.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/highlight.css">

</head>
<body>
    <header id="header">
    <div class="nav-warp">
      <nav id="nav" class="w">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/about/#link">Link</a>
        
          <a class="main-nav-link" href="/atom.xml">RSS</a>
        
          <a class="main-nav-link" href="https://github.com/neargle">Project</a>
        
        <a id="nav-search" class="icon-search fr" onclick="show_search()" title="搜索"></a>
        <div id="nav-search-input" class="hide">
          <form class="search-form" onsubmit="return dispatch()">
            <input type="hidden" id="site" value="site:http://blog.neargle.com">
            <input type="text" id="q" class="input-text" name="q" placeholder="搜索">
            <input type="submit" value="" class="input-submit">
          </form>
        </div>
      </nav>
    </div>
    
  </header>

  <!-- <div id='wrap'> -->
    <div id='outer'>
      <section id="main"><article class="post">
  <header class="post-head">
    
  
    
      <h1 class="post-title">Django的两则url跳转漏洞:CVE-2017-7233和CVE-2017-7234分析</h1>
    
  

    
<time datetime="2017-04-12T15:55:00.000Z" class="post-time">2017-04-12</time>

  </header>
  
  <section class="post-content typo">
    <p><a href="https://www.djangoproject.com/weblog/2017/apr/04/security-releases/" target="_blank" rel="external">Django官方News&amp;Event</a>在4月4日发布了一个安全更新，修复了两个URL跳转的漏洞，一个是urlparse的锅，另一个来自国内的安全研究员 phithon@长亭,都非常漂亮。因为有复现Django漏洞的习惯，晚上抽了点时间复现了一下。有趣的点还挺多。把两个漏洞的分析整合在一起，凑了篇文章。（还是研究漏洞有趣啊，泪流满面QAQ）</p>
<h2 id="CVE-2017-7233分析">CVE-2017-7233分析</h2><p>国外安全研究员roks0n提供给Django官方的一个漏洞。</p>
<p><img src="http://ww1.sinaimg.cn/large/005y7Ba5gy1fekb8wapitj317d0pxage.jpg" alt=""></p>
<a id="more"></a>
<h3 id="关于is_safe_url函数">关于is_safe_url函数</h3><p>Django自带一个函数：<code>django.utils.http.is_safe_url(url, host=None, allowed_hosts=None, require_https=False)</code>，用于过滤需要进行跳转的url。如果url安全则返回ture，不安全则返回false。文档如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(is_safe_url.__doc__)</span><br><span class="line"></span><br><span class="line">Return ``True`` if the url is a safe redirection (i.e. it doesn't point to</span><br><span class="line">a different host and uses a safe scheme).</span><br><span class="line"></span><br><span class="line">Always returns ``False`` on an empty url.</span><br><span class="line"></span><br><span class="line">If ``require_https`` is ``True``, only 'https' will be considered a valid</span><br><span class="line">scheme, as opposed to 'http' and 'https' with the default, ``False``.</span><br></pre></td></tr></table></figure>
<p>让我们来看看常规的几个用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.http <span class="keyword">import</span> is_safe_url</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: is_safe_url(<span class="string">'http://baidu.com'</span>)</span><br><span class="line">Out[<span class="number">2</span>]: <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: is_safe_url(<span class="string">'baidu.com'</span>)</span><br><span class="line">Out[<span class="number">3</span>]: <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: is_safe_url(<span class="string">'aaaaa'</span>)</span><br><span class="line">Out[<span class="number">5</span>]: <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: is_safe_url(<span class="string">'//blog.neargle.com'</span>)</span><br><span class="line">Out[<span class="number">8</span>]: <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: is_safe_url(<span class="string">'http://google.com/adadadadad'</span>,<span class="string">'blog.neargle.com'</span>)</span><br><span class="line">Out[<span class="number">7</span>]: <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: is_safe_url(<span class="string">'http://blog.neargle.com/aaaa/bbb'</span>, <span class="string">'blog.neargle.com'</span>)</span><br><span class="line">Out[<span class="number">13</span>]: <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>可见在没有指定第二个参数host的情况下,url如果非相对路径，即<code>HttpResponseRedirect</code>函数会跳往别的站点的情况，<code>is_safe_url</code>就判断其为不安全的url,如果指定了host为<code>blog.neargle.com</code>，则<code>is_safe_url</code>会判断url是否属于’blog.neargle.com’，如果url是’blog.neargle.com’或相对路径的url，则判断其url是安全的。</p>
<h3 id="urllib-parse-urlparse的特殊情况">urllib.parse.urlparse的特殊情况</h3><p>问题就出在该函数对域名和方法的判断，是基于<code>urllib.parse.urlparse</code>的,源码如下(django/utils/http.py):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_is_safe_url</span><span class="params">(url, host)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> url.startswith(<span class="string">'///'</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    url_info = urlparse(url)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> url_info.netloc <span class="keyword">and</span> url_info.scheme:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">if</span> unicodedata.category(url[<span class="number">0</span>])[<span class="number">0</span>] == <span class="string">'C'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">not</span> url_info.netloc <span class="keyword">or</span> url_info.netloc == host) <span class="keyword">and</span></span><br><span class="line">            (<span class="keyword">not</span> url_info.scheme <span class="keyword">or</span> url_info.scheme <span class="keyword">in</span> [<span class="string">'http'</span>, <span class="string">'https'</span>]))</span><br></pre></td></tr></table></figure>
<p>我们来看一下urlparse的常规用法及几种urlparse无法处理的特殊情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>urlparse(<span class="string">'http://blog.neargle.com/2017/01/09/chrome-ext-spider-for-probe/'</span>)</span><br><span class="line">ParseResult(scheme=<span class="string">'http'</span>, netloc=<span class="string">'blog.neargle.com'</span>, path=<span class="string">'/2017/01/09/chrome-ext-spider-for-probe/'</span>, params=<span class="string">''</span>, query=<span class="string">''</span>, fragment=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>urlparse(<span class="string">'ftp:99999999'</span>)</span><br><span class="line">ParseResult(scheme=<span class="string">''</span>, netloc=<span class="string">''</span>, path=<span class="string">'ftp:99999999'</span>, params=<span class="string">''</span>, query=<span class="string">''</span>, fragment=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>urlparse(<span class="string">'http:99999999'</span>)</span><br><span class="line">ParseResult(scheme=<span class="string">'http'</span>, netloc=<span class="string">''</span>, path=<span class="string">'99999999'</span>, params=<span class="string">''</span>, query=<span class="string">''</span>, fragment=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>urlparse(<span class="string">'https:99999999'</span>)</span><br><span class="line">ParseResult(scheme=<span class="string">''</span>, netloc=<span class="string">''</span>, path=<span class="string">'https:99999999'</span>, params=<span class="string">''</span>, query=<span class="string">''</span>, fragment=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>urlparse(<span class="string">'javascript:222222'</span>)</span><br><span class="line">ParseResult(scheme=<span class="string">''</span>, netloc=<span class="string">''</span>, path=<span class="string">'javascript:222222'</span>, params=<span class="string">''</span>, query=<span class="string">''</span>, fragment=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>urlparse(<span class="string">'ftp:aaaaaaa'</span>)</span><br><span class="line">ParseResult(scheme=<span class="string">'ftp'</span>, netloc=<span class="string">''</span>, path=<span class="string">'aaaaaaa'</span>, params=<span class="string">''</span>, query=<span class="string">''</span>, fragment=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>urlparse(<span class="string">'ftp:127.0.0.1'</span>)</span><br><span class="line">ParseResult(scheme=<span class="string">'ftp'</span>, netloc=<span class="string">''</span>, path=<span class="string">'127.0.0.1'</span>, params=<span class="string">''</span>, query=<span class="string">''</span>, fragment=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>urlparse(<span class="string">'ftp:127.0.0.1'</span>)</span><br><span class="line">ParseResult(scheme=<span class="string">'ftp'</span>, netloc=<span class="string">''</span>, path=<span class="string">'127.0.0.1'</span>, params=<span class="string">''</span>, query=<span class="string">''</span>, fragment=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>可以发现当scheme不等于http，且path为纯数字的时候,urlparse处理例如<code>aaaa:2222222223</code>的情况是不能正常分割开的，会全部归为path。这时<code>url_info.netloc == url_info.scheme == &quot;&quot;</code>,则<code>((not url_info.netloc or url_info.netloc == host) and (not url_info.scheme or url_info.scheme in [&#39;http&#39;, &#39;https&#39;]))</code>为true。（这里顺便提一下,<a href="https://www.djangoproject.com/weblog/2017/apr/04/security-releases/" target="_blank" rel="external">django官方News&amp;Event</a>中提到的poc:”http:99999999”是无法bypass的，在前面的判断<code>if not url_info.netloc and url_info.scheme:</code>都过不了。）例如下面几种情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>is_safe_url(<span class="string">'http:555555555'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>is_safe_url(<span class="string">'ftp:23333333333'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>is_safe_url(<span class="string">'https:2333333333'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="使用IP_Decimal_Bypass_is_safe_url">使用IP Decimal Bypass is_safe_url</h3><p>但是既然是url跳转漏洞，我们就需要让其跳转到指定的url里，<code>https:2333333333</code>这样的url明显是无法访问的，而冒号之后必须纯数字,<code>http:127.0.0.1</code>是无法pypass的。有什么方法呢？其实ip不仅只有常见的点分十进制表示法,纯十进制数字也可以表示一个ip地址,浏览器也同样支持。例如: <code>127.0.0.1 == 2130706433</code>, <code>8.8.8.8 == 134744072</code>(转换器:<a href="http://www.ipaddressguide.com/ip),而&#39;http:2130706433&#39;是在浏览器上是可以访问到对应的ip及服务的，即&#39;http:2130706433" target="_blank" rel="external">http://www.ipaddressguide.com/ip),而&#39;http:2130706433&#39;是在浏览器上是可以访问到对应的ip及服务的，即&#39;http:2130706433</a> = <a href="http://127.0.0.1/&#39;。" target="_blank" rel="external">http://127.0.0.1/&#39;。</a></p>
<p>这里我们选用<code>https:1029415385</code>作为poc，这是一个google的ip,这个url可以bypass<code>is_safe_url</code>并跳转到google.com。</p>
<h3 id="漏洞验证与影响">漏洞验证与影响</h3><p>我们来写一个简单的环境:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.utils.http <span class="keyword">import</span> is_safe_url</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BypassIsUrlSafeCheck</span><span class="params">(request)</span>:</span></span><br><span class="line">    url = request.GET.get(<span class="string">"url"</span>, <span class="string">''</span>)</span><br><span class="line">    <span class="keyword">if</span> is_safe_url(url, host=<span class="string">"blog.neargle.com"</span>):</span><br><span class="line">        <span class="keyword">return</span> HttpResponseRedirect(url)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> HttpResponseRedirect(<span class="string">'/'</span>)</span><br></pre></td></tr></table></figure></p>
<p>然后访问:<code>http://127.0.0.1:8000/bypassIsUrlSafeCheck?url=https:1029415385</code>, 如图,url被重定向到了google.com。<br><img src="http://ww1.sinaimg.cn/large/005y7Ba5gy1fek9xcdj0mj317w0dfdmx.jpg" alt=""></p>
<p>并非只有开发者自己使用<code>is_safe_url</code>会受到影响，Django默认自带的admin也使用了这个函数来处理next GET | POST参数，当用户访问<code>/admin/login/?next=https:1029415385</code>进行登录时，登录后同样会跳转到google.com,退出登录时同样使用到了该函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_login_redirect_url</span><span class="params">(request, redirect_to)</span>:</span></span><br><span class="line">    <span class="comment">#### Ensure the user-originating redirection URL is safe.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_safe_url(url=redirect_to, host=request.get_host()):</span><br><span class="line">        <span class="keyword">return</span> resolve_url(settings.LOGIN_REDIRECT_URL)</span><br><span class="line">    <span class="keyword">return</span> redirect_to</span><br><span class="line"></span><br><span class="line"><span class="decorator">@never_cache</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(request, template_name=<span class="string">'registration/login.html'</span>,</span><br><span class="line">          redirect_field_name=REDIRECT_FIELD_NAME,</span><br><span class="line">          authentication_form=AuthenticationForm,</span><br><span class="line">          extra_context=None, redirect_authenticated_user=False)</span>:</span></span><br><span class="line">    ......</span><br><span class="line">            <span class="keyword">return</span> HttpResponseRedirect(_get_login_redirect_url(request, redirect_to))</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/005y7Ba5gy1fekaefgrp6j31et0cl13b.jpg" alt=""></p>
<h3 id="修复">修复</h3><p>django修复了代码，自己重构了一下<code>urlparse</code>函数,修复了<code>urlparse</code>函数的这个漏洞。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_urlparse</span><span class="params">(url, scheme=<span class="string">''</span>, allow_fragments=True)</span>:</span></span><br><span class="line">    <span class="string">"""Parse a URL into 6 components:</span><br><span class="line">    &lt;scheme&gt;://&lt;netloc&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;fragment&gt;</span><br><span class="line">    Return a 6-tuple: (scheme, netloc, path, params, query, fragment).</span><br><span class="line">    Note that we don't break the components up in smaller bits</span><br><span class="line">    (e.g. netloc is a single string) and we don't expand % escapes."""</span></span><br><span class="line">    url, scheme, _coerce_result = _coerce_args(url, scheme)</span><br><span class="line">    splitresult = _urlsplit(url, scheme, allow_fragments)</span><br><span class="line">    scheme, netloc, url, query, fragment = splitresult</span><br><span class="line">    <span class="keyword">if</span> scheme <span class="keyword">in</span> uses_params <span class="keyword">and</span> <span class="string">';'</span> <span class="keyword">in</span> url:</span><br><span class="line">        url, params = _splitparams(url)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        params = <span class="string">''</span></span><br><span class="line">    result = ParseResult(scheme, netloc, url, params, query, fragment)</span><br><span class="line">    <span class="keyword">return</span> _coerce_result(result)</span><br></pre></td></tr></table></figure>
<h3 id="关于官方提到的_possible_XSS_attack">关于官方提到的 possible XSS attack</h3><p><a href="https://www.djangoproject.com/weblog/2017/apr/04/security-releases/" target="_blank" rel="external">django官方News&amp;Event</a>中提到的这个漏洞可能会产生XSS，我认为除非程序员把接受跳转的url插入的到<code>&lt;script type=&quot;text/javascript&quot; src=&quot;&quot;&gt;&lt;/script&gt;</code>等特殊情况之外，直接使用产生XSS的场景还是比较少的。如果你想到了其他的场景还请赐教，祝好。</p>
<h2 id="CVE-2017-7234_分析">CVE-2017-7234 分析</h2><h3 id="漏洞详情">漏洞详情</h3><p>来自 @Phithon 的一个漏洞。</p>
<p>问题出现在：<code>django.views.static.serve()</code>函数上。该函数可以用来指定web站点的静态文件目录。如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^admin/'</span>, admin.site.urls),</span><br><span class="line">    url(<span class="string">r'^staticp/(?P&lt;path&gt;.*)$'</span>, serve, &#123;<span class="string">'document_root'</span>: os.path.join(settings.BASE_DIR, <span class="string">'staticpath'</span>)&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这样django项目根目录下staticpath中的所有文件，就可以在staticp/目录中访问。e.g. <code>http://127.0.0.1:8000/staticp/test.css</code></p>
<p>这种方法是不被django官方推荐在生成环境使用的，对安全性和性能都有一定影响。</p>
<p>问题代码如下 (django/views/static.py)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">path = posixpath.normpath(unquote(path))</span><br><span class="line">path = path.lstrip(<span class="string">'/'</span>)</span><br><span class="line">newpath = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> part <span class="keyword">in</span> path.split(<span class="string">'/'</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> part:</span><br><span class="line">        <span class="comment">#### Strip empty path components.</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    drive, part = os.path.splitdrive(part)</span><br><span class="line">    head, part = os.path.split(part)</span><br><span class="line">    <span class="keyword">if</span> part <span class="keyword">in</span> (os.curdir, os.pardir):</span><br><span class="line">        <span class="comment">#### Strip '.' and '..' in path.</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    newpath = os.path.join(newpath, part).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>)</span><br><span class="line"><span class="keyword">if</span> newpath <span class="keyword">and</span> path != newpath:</span><br><span class="line">    <span class="keyword">return</span> HttpResponseRedirect(newpath)</span><br></pre></td></tr></table></figure>
<p>path既我们传入的路径,如果传入的路径为<code>staticp/path.css</code>,则<code>path=path.css</code>。跟踪代码可知，path经过了unquote进行url解码，后来又<code>replace(&#39;\\&#39;, &#39;/&#39;)</code>,进入HttpResponseRedirect，很诡异的逻辑看起来很有问题。一般遇到这类型的函数我们会先试着找看看,任意文件读漏洞，但是这个对<code>&#39;.&#39;</code>和<code>&#39;..&#39;</code>进行了过滤，所以这边这个HttpResponseRedirect函数就成了帅的人的目标。</p>
<p>我们的最终目的是<code>HttpResponseRedirect(&#39;//evil.neargle.com&#39;)</code>或者<code>HttpResponseRedirect(&#39;http://evil.neargle.com&#39;)</code>,那么就要使<code>path != newpath</code>，那么path里面就必须带有’\‘，好的现在的我们传入<code>&#39;/staticp/%5C%5Cblog.neargle.com&#39;</code>,则<code>path=&#39;\\\\blog.neargle.com&#39;;newpath=&#39;//blog.neargle.com&#39;</code>,HttpResponseRedirect就会跳转到<code>&#39;blog.neargle.com&#39;</code>造成跳转漏洞。</p>
<h3 id="修复-1">修复</h3><p><img src="http://ww1.sinaimg.cn/large/005y7Ba5gy1fekcmmfjskj31e60l1q87.jpg" alt=""></p>
<p>嗯，官方表示自己也不知道为什么要写这串代码，删了这一串代码然后用safe_url函数代替。</p>
<h3 id="ps-">ps.</h3><p>浏览器不仅仅支持十进制来代替点分十进制的IP，也可以使用十六进制和8进制来代替。<code>http://点分十进制 == http://十进制 == http://0x十六进制 == http://0八进制</code>(例如:<code>http://127.0.0.1 == http://2130706433 == http://0x7F000001 == http://017700000001</code>),十六进制非纯数字所以不可用来bypass urlparse，但是八进制还是可以的。</p>
<h3 id="urls">urls</h3><ul>
<li><a href="https://github.com/django/django/commit/5ea48a70afac5e5684b504f09286e7defdd1a81a" target="_blank" rel="external">https://github.com/django/django/commit/5ea48a70afac5e5684b504f09286e7defdd1a81a</a></li>
<li><a href="https://www.djangoproject.com/weblog/2017/apr/04/security-releases/" target="_blank" rel="external">https://www.djangoproject.com/weblog/2017/apr/04/security-releases/</a></li>
<li><a href="https://docs.python.org/3/library/urllib.parse.html" target="_blank" rel="external">https://docs.python.org/3/library/urllib.parse.html</a></li>
</ul>

    <p class="origin-url">本文URL： <a href="http://blog.neargle.com/2017/04/12/Django-CVE-2017-7233-bypass-is-safe-url-and-CVE-2017-7233-serve-open-url/index.html">http://blog.neargle.com/2017/04/12/Django-CVE-2017-7233-bypass-is-safe-url-and-CVE-2017-7233-serve-open-url/index.html</a></p>
  </section>
  
  <footer class="post-foot">
    <section class="post-foot-warp clear">
      
  <ul class="post-tag icon-tag fl">
    
      <li><a href="/tags/漏洞分析/">#漏洞分析</a></li>
    
  </ul>

      
    </section>
  </footer>
  
</article>

    
<nav id="post-nav" class="clear">
  
    <a href="/2017/09/01/ddctf-web-xss-sqli-writeup/" id="post-nav-newer" class="post-nav-link-wrap fl" title="ddctf 两道web题的Writeup (sqli &amp; xss)">
      <div class="post-nav-title">&laquo; ddctf 两道web题的Writeup (sqli &amp; xss)</div>
    </a>
  
  
    <a href="/2017/01/09/chrome-ext-spider-for-probe/" id="post-nav-older" class="post-nav-link-wrap fr" title="Chrome Extensions Spider &amp; Downloader">
      <div class="post-nav-title">Chrome Extensions Spider &amp; Downloader &raquo;</div>
    </a>
  
</nav>



<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
    </div>
  <!-- </div> -->
    <footer id="footer">
    <div class="foot-warp">
      <p>© 2014 Nearg1e</p>
    </div>
  </footer>
  <script src="/js/tools.js"></script>
  
  
  <script>
    var disqus_shortname = 'neargle';
    
    var disqus_url = 'http://blog.neargle.com/2017/04/12/Django-CVE-2017-7233-bypass-is-safe-url-and-CVE-2017-7233-serve-open-url/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  
  
</body>
</html>
